import { readdir, readFile, writeFile } from 'fs/promises';
import { basename, join, relative } from 'path';

interface FileInfo {
  path: string;
  name: string;
  isDirectory: boolean;
}

interface ExportInfo {
  name: string;
  path: string;
  isType: boolean;
}

// Directories to skip
const SKIP_DIRS = new Set(['node_modules', '.git', 'dist', 'build', '__tests__', 'test']);

// Files to skip
const SKIP_FILES = new Set(['index.ts', 'index.tsx', 'types.ts', 'types.tsx']);

async function getFiles(dir: string): Promise<FileInfo[]> {
  const entries = await readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map(async (entry) => {
      const path = join(dir, entry.name);
      return {
        path,
        name: entry.name,
        isDirectory: entry.isDirectory(),
      };
    })
  );
  return files;
}

async function analyzeFileContent(filePath: string): Promise<ExportInfo[]> {
  try {
    const content = await readFile(filePath, 'utf-8');
    const exports: ExportInfo[] = [];

    // Basic regex patterns for export detection
    const exportPatterns = [
      /export\s+(?:type\s+)?(?:interface|type|class|function|const|let|var)\s+(\w+)/g,
      /export\s+default\s+(?:class|function|const|let|var)\s+(\w+)/g,
    ];

    for (const pattern of exportPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const isType = content.slice(match.index, match.index + 10).includes('type ');
        exports.push({
          name: match[1],
          path: filePath,
          isType,
        });
      }
    }

    return exports;
  } catch (error) {
    console.warn(`Warning: Could not analyze file ${filePath}:`, error);
    return [];
  }
}

async function generateBarrelFile(dir: string): Promise<void> {
  const files = await getFiles(dir);
  const exports: string[] = [];
  const typeExports: string[] = [];
  const subDirs: string[] = [];

  // Skip if directory is in SKIP_DIRS
  if (SKIP_DIRS.has(basename(dir))) {
    return;
  }

  for (const file of files) {
    if (SKIP_FILES.has(file.name)) continue;

    if (file.isDirectory) {
      subDirs.push(file.path);
      continue;
    }

    if (file.name.endsWith('.ts') || file.name.endsWith('.tsx')) {
      const relativePath = relative(dir, file.path);
      const exportName = basename(file.name, file.name.endsWith('.tsx') ? '.tsx' : '.ts');

      // Analyze file content for specific exports
      const fileExports = await analyzeFileContent(file.path);

      if (fileExports.length > 0) {
        // Add specific exports
        fileExports.forEach(exp => {
          const exportLine = `export { ${exp.name} } from './${exportName}';`;
          if (exp.isType) {
            typeExports.push(exportLine);
          } else {
            exports.push(exportLine);
          }
        });
      } else {
        // Fallback to namespace export
        exports.push(`export * from './${exportName}';`);
      }
    }
  }

  // Generate barrel file content with organization
  const barrelContent = [
    '// Auto-generated barrel file',
    '// Do not edit this file directly',
    '',
    // Regular exports
    ...exports,
    '',
    // Type exports
    ...typeExports,
  ].join('\n') + '\n';

  // Write the barrel file
  await writeFile(join(dir, 'index.ts'), barrelContent);

  // Recursively generate barrel files for subdirectories
  for (const subDir of subDirs) {
    await generateBarrelFile(subDir);
  }
}

async function main() {
  const srcDir = join(process.cwd(), 'src');
  try {
    console.log('Starting barrel file generation...');
    await generateBarrelFile(srcDir);
    console.log('✅ Barrel files generated successfully!');
  } catch (error) {
    console.error('❌ Error generating barrel files:', error);
    process.exit(1);
  }
}

main();
